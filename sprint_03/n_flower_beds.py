"""
N. Клумбы

Алла захотела, чтобы у неё под окном были узкие клумбы с тюльпанам. На схеме 
земельного участка клумбы обозначаются просто горизонтальными отрезками, 
лежащими на одной прямой. Для ландшафтных работ было нанято n садовников. 
Каждый из них обрабатывал какой-то отрезок на схеме. Процесс был организован 
не очень хорошо, иногда один и тот же отрезок или его часть могли быть 
обработаны сразу несколькими садовниками. Таким образом, отрезки, 
обрабатываемые двумя разными садовниками, сливаются в один. Непрерывный 
обработанный отрезок затем станет клумбой. Нужно определить границы будущих 
клумб.
Рассмотрим примеры.
Пример 1:
Даны 4 отрезка: [7,8],[7,8] ,[2,3],[6,10]. Два одинаковых отрезка [7,8] и
[7,8] сливаются в один, но потом их накрывает отрезок [6,10]. Таким образом, 
имеем две клумбы с координатами [2,3] и [6,10].

Пример 2
Во втором сэмпле опять 4 отрезка: [2,3], [3,4], [3,4], [5,6]. Отрезки 
[2,3], [3,4] и [3,4] сольются в один отрезок [2,4]. Отрезок 
[5,6] ни с кем не объединяется, добавляем его в ответ.

Формат ввода
В первой строке задано количество садовников 
n
. Число садовников не превосходит 100000.В следующих n
 строках через пробел записаны координаты клумб в формате: start end, где 
 start —– координата начала, end —– координата конца. Оба числа целые, 
 неотрицательные и не превосходят 107. start строго меньше, чем end.

Формат вывода
Нужно вывести координаты каждой из получившихся клумб в отдельных строках. 
Данные должны выводиться в отсортированном порядке —– сначала клумбы с меньшими 
координатами, затем —– с бОльшими.

Пример 1
Ввод	Вывод
4
7 8
7 8
2 3
6 10
        2 3
        6 10

Пример 2
Ввод	Вывод
4
2 3
5 6
3 4
3 4
        2 4
        5 6

Пример 3
Ввод	Вывод
6
1 3
3 5
4 6
5 6
2 4
7 10
        1 6
        7 10
"""

nums = [[7,9],[7,8],[2,3],[6,10]]
n = 4
def merge_sort(nums): 
    if len(nums) > 1: 
        mid = len(nums)//2
        left = nums[:mid] 
        right = nums[mid:]
        merge_sort(left) 
        merge_sort(right) 
        l = r = k = 0
        while l < len(left) and r < len(right): 
            if left[l] < right[r]: 
                nums[k] = left[l] 
                l+=1
            else: 
                nums[k] = right[r] 
                r+=1
            k+=1
        while l < len(left): 
            nums[k] = left[l] 
            l+=1
            k+=1
        while r < len(right): 
            nums[k] = right[r] 
            r+=1
            k+=1

def solution(nums):
    result = [nums[0]]
    for i in range(1, len(nums)):
        if nums[i][0] == result[-1][0]:
            result[-1][0] = result[i][0]
        elif nums[i][0] > result[-1][0] and nums[i][1] > result[-1][1]:
            result.append(nums[i])
    return result
        
merge_sort(nums)
print(nums)
result = solution(nums)
for i in result:
    print(*i, sep=' ')